//---------------------------------------------------------------------------

#pragma hdrstop

#include "Unit1.h"
//---------------------------------------------------------------------------
#pragma package(smart_init)

list2 * list2::init(int a) { // а- значение первого узла
	list2 *lst;
	// выделение памяти под корень списка
	lst = (list2*)malloc(sizeof(list2));
	lst->field = a;
	lst->next = NULL; // указатель на следующий узел
	lst->prev = NULL; // указатель на предыдущий узел
	return(lst);
}

list2 * list2::addelem(list2 *lst, int number) {
	list2 *temp, *p;
	temp = (list2*)malloc(sizeof(list2));
	p = lst->next; // сохранение указателя на следующий узел
	lst->next = temp; // предыдущий узел указывает на создаваемый
	temp->field = number; // сохранение поля данных добавляемого узла
	temp->next = p; // созданный узел указывает на следующий узел
	temp->prev = lst; // созданный узел указывает на предыдущий узел
	if (p != NULL)
		p->prev = temp;
	return(temp);
}

list2 * list2::deletelem(list2 *lst) {
	list2 *prev, *next;
	prev = lst->prev; // узел, предшествующий lst
	next = lst->next; // узел, следующий за lst
	if (prev != NULL)
		prev->next = lst->next; // переставляем указатель
	if (next != NULL)
		next->prev = lst->prev; // переставляем указатель
	free(lst); // освобождаем память удаляемого элемента
	return(prev);
}

list2 * list2::deletehead(list2 *root) {
	list2 *temp;
	temp = root->next;
	temp->prev = NULL;
	free(root);   // освобождение памяти текущего корня
	return(temp); // новый корень списка
}

void list2::list_unique(list2* lst)
{
	list2 *t, *p, *i, *prev, *temp;
	int first = 0;
	for(p = lst; p != NULL; p = p->next)
	{
		bool check = false;
		temp = p;
        prev = p;
		for(i = p->next; i != NULL; )
		{
			if(i->field == p->field)
			{
				check = true;
                t = prev->next = i->next;
                free(i);
                i = t;
                continue;
            }
            prev = i;
			i = i->next;
		}
		if(check == true && first == 0)
		{
			//deletehead(p);
            list2 *temp;
			temp = p->next;
			temp->prev = NULL;
			free(p);   // освобождение памяти текущего корня
			//return(temp);
		}
		else if(check == true)
		{
			deletelem(p);
		}
		first++;
	}
}

/*void listprint(list *lst) {
	struct list *p;
	p = lst;
	do {
		printf("%d ", p->field); // вывод значения элемента p
		p = p->next; // переход к следующему узлу
	} while (p != NULL); // условие окончания обхода
}*/

/*void listprintr(list *lst) {
	struct list *p;
	p = lst;
	while (p->next != NULL)
		p = p->next;  // переход к концу списка
	do {
		printf("%d ", p->field); // вывод значения элемента p
		p = p->next; // переход к следующему узлу
	} while (p != NULL); // условие окончания обхода
}*/
